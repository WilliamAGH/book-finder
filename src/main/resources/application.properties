# Base application properties, provides common defaults
# Inherited by profile-specific .properties files (dev, prod, test)
# Values here can be overridden by application.yml or profile-specific files
spring.application.name=book_recommendation_engine

# Server configuration
# Default port 8081, overridden by application.yml's SERVER_PORT:8080 if not set elsewhere
server.port=${SERVER_PORT:8081}

# Database configuration
# Default to no URL to activate NoDatabaseConfig if SPRING_DATASOURCE_URL is not set
# When a database is available for an environment, set SPRING_DATASOURCE_URL or override in a profile
spring.datasource.url=${SPRING_DATASOURCE_URL:}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:}

# OpenAI configuration
spring.ai.openai.api-key=${SPRING_AI_OPENAI_API_KEY:}
spring.ai.openai.model=${SPRING_AI_OPENAI_MODEL:gpt-4}
spring.ai.openai.audio.speech.enabled=false

# Exclude all OpenAI auto-configurations (Chat, Embedding, Image, Moderation) when no API key is set
# Exclude JPA and DataSource auto-configuration as we are moving to Redis-only persistence
spring.autoconfigure.exclude=org.springframework.ai.model.openai.autoconfigure.OpenAiChatAutoConfiguration,org.springframework.ai.model.openai.autoconfigure.OpenAiEmbeddingAutoConfiguration,org.springframework.ai.model.openai.autoconfigure.OpenAiImageAutoConfiguration,org.springframework.ai.model.openai.autoconfigure.OpenAiModerationAutoConfiguration,org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration

# Google Books API configuration
googlebooks.api.url=https://www.googleapis.com/books
googlebooks.api.key=${GOOGLE_BOOKS_API_KEY:}
google.books.api.max-results=40
google.books.api.connect-timeout=5000
google.books.api.read-timeout=5000

# S3 Compatible Storage configuration
s3.access-key-id=${S3_ACCESS_KEY_ID}
s3.secret-access-key=${S3_SECRET_ACCESS_KEY}
s3.region=${AWS_REGION:us-east-1}
s3.bucket-name=${S3_BUCKET_NAME:book-finder}
s3.cdn-url=${S3_CDN_URL}
s3.public-cdn-url=${S3_PUBLIC_CDN_URL:#{null}}
s3.server-url=${S3_SERVER_URL:https://sfo3.digitaloceanspaces.com}
s3.enabled=${S3_ENABLED:true}

# S3 retry configuration
s3.retry.max-attempts=3
s3.retry.initial-backoff-ms=200
s3.retry.backoff-multiplier=2.0

# Affiliate Link Configuration
affiliate.barnesandnoble.publisher-id=
affiliate.barnesandnoble.website-id=
affiliate.bookshop.affiliate-id=113888
affiliate.amazon.associate-tag=williamagh-20

# Sitemap configuration
sitemap.s3.accumulated-ids-key=${SITEMAP_S3_ACCUMULATED_IDS_KEY:sitemap/accumulated-book-ids.json}

# Book cover cache configuration
app.cover-cache.enabled=true
app.cover-cache.dir=covers
app.cover-cache.max-age-days=30
app.cover-cache.cleanup-interval-hours=24
# Maximum file size in bytes for cached cover images
# Default is 5MB (5 * 1024 * 1024 = 5242880 bytes)
app.cover-cache.max-file-size-bytes=5242880

# Book cover debug mode
# When true, logs detailed JSON information about cover image sources to S3 alongside the image
book.cover.debug-mode=false

# Increase async request timeout for deferred results
spring.mvc.async.request-timeout=60s

# Tune Tomcat connection and thread settings
server.connection-timeout=60s
server.tomcat.max-threads=200
server.tomcat.min-spare-threads=20
server.tomcat.accept-count=100

# SMTP Configuration for later
# spring.mail.host=smtp.example.com

# Resilience4j Circuit Breaker Configuration
resilience4j.circuitbreaker.instances.googleBooksService.registerHealthIndicator=true
resilience4j.circuitbreaker.instances.googleBooksService.slidingWindowType=COUNT_BASED
resilience4j.circuitbreaker.instances.googleBooksService.slidingWindowSize=10
resilience4j.circuitbreaker.instances.googleBooksService.minimumNumberOfCalls=5
resilience4j.circuitbreaker.instances.googleBooksService.failureRateThreshold=50
resilience4j.circuitbreaker.instances.googleBooksService.waitDurationInOpenState=30s
resilience4j.circuitbreaker.instances.googleBooksService.permittedNumberOfCallsInHalfOpenState=3
resilience4j.circuitbreaker.instances.googleBooksService.automaticTransitionFromOpenToHalfOpenEnabled=true

resilience4j.circuitbreaker.instances.openLibraryService.registerHealthIndicator=true
resilience4j.circuitbreaker.instances.openLibraryService.slidingWindowType=COUNT_BASED
resilience4j.circuitbreaker.instances.openLibraryService.slidingWindowSize=10
resilience4j.circuitbreaker.instances.openLibraryService.minimumNumberOfCalls=5
resilience4j.circuitbreaker.instances.openLibraryService.failureRateThreshold=60
resilience4j.circuitbreaker.instances.openLibraryService.waitDurationInOpenState=60s
resilience4j.circuitbreaker.instances.openLibraryService.permittedNumberOfCallsInHalfOpenState=2

resilience4j.circuitbreaker.instances.longitoodService.registerHealthIndicator=true
resilience4j.circuitbreaker.instances.longitoodService.slidingWindowType=COUNT_BASED
resilience4j.circuitbreaker.instances.longitoodService.slidingWindowSize=10
resilience4j.circuitbreaker.instances.longitoodService.minimumNumberOfCalls=5
resilience4j.circuitbreaker.instances.longitoodService.failureRateThreshold=70
resilience4j.circuitbreaker.instances.longitoodService.waitDurationInOpenState=60s
resilience4j.circuitbreaker.instances.longitoodService.permittedNumberOfCallsInHalfOpenState=2

# OpenLibrary Data API configuration
openlibrary.data.api.url=https://openlibrary.org
# Adhere to ~1 req/sec
openlibrary.data.api.request-limit-per-second=1
# Resilience4j for OpenLibraryBookDataService
resilience4j.ratelimiter.instances.openLibraryDataService.limitRefreshPeriod=1s
resilience4j.ratelimiter.instances.openLibraryDataService.limitForPeriod=${openlibrary.data.api.request-limit-per-second:1}
resilience4j.ratelimiter.instances.openLibraryDataService.timeoutDuration=0
resilience4j.circuitbreaker.instances.openLibraryDataService.registerHealthIndicator=true
resilience4j.circuitbreaker.instances.openLibraryDataService.slidingWindowType=COUNT_BASED
resilience4j.circuitbreaker.instances.openLibraryDataService.slidingWindowSize=10
resilience4j.circuitbreaker.instances.openLibraryDataService.minimumNumberOfCalls=5
resilience4j.circuitbreaker.instances.openLibraryDataService.failureRateThreshold=50
resilience4j.circuitbreaker.instances.openLibraryDataService.waitDurationInOpenState=60s
# Consistent with other services
resilience4j.circuitbreaker.instances.openLibraryDataService.permittedNumberOfCallsInHalfOpenState=2
# Generous timeout for external free API
resilience4j.timelimiter.instances.openLibraryDataService.timeoutDuration=10s

# Longitood Data API configuration (Placeholder - update with actuals if API exists)
# longitood.data.api.url=https://api.longitood.example.com # Commented out as Longitood is cover-only
# longitood.data.api.request-limit-per-second=1 # Commented out
# Resilience4j for LongitoodBookDataService (Data fetching part, now removed)
# resilience4j.ratelimiter.instances.longitoodDataService.limitRefreshPeriod=1s
# resilience4j.ratelimiter.instances.longitoodDataService.limitForPeriod=${longitood.data.api.request-limit-per-second:1}
# resilience4j.ratelimiter.instances.longitoodDataService.timeoutDuration=0
# resilience4j.circuitbreaker.instances.longitoodDataService.registerHealthIndicator=true
# resilience4j.circuitbreaker.instances.longitoodDataService.slidingWindowType=COUNT_BASED
# resilience4j.circuitbreaker.instances.longitoodDataService.slidingWindowSize=10
# resilience4j.circuitbreaker.instances.longitoodDataService.minimumNumberOfCalls=5
# resilience4j.circuitbreaker.instances.longitoodDataService.failureRateThreshold=50
# resilience4j.circuitbreaker.instances.longitoodDataService.waitDurationInOpenState=60s
# resilience4j.circuitbreaker.instances.longitoodDataService.permittedNumberOfCallsInHalfOpenState=2
# resilience4j.timelimiter.instances.longitoodDataService.timeoutDuration=10s

# Default TimeLimiter configuration (can be overridden per instance)
resilience4j.timelimiter.instances.defaultConfig.timeoutDuration=5s
resilience4j.timelimiter.instances.defaultConfig.cancelRunningFuture=true

# Actuator Configuration
management.endpoints.web.exposure.include=health,info,prometheus
management.endpoint.health.show-details=when_authorized
# Show circuit breaker states in health endpoint
management.health.circuitbreakers.enabled=true
# Show DB health (if spring-boot-starter-data-jpa is present)
management.health.db.enabled=true
# Show disk space health
management.health.diskspace.enabled=true

# Test Book ID for health check
healthcheck.test-book-id=Hn41AgAAQBAJ # Example Book ID, replace with a stable ID from your system

# Disable default Redis health indicator to use the custom resilient one
management.health.redis.enabled=false

# ======================================================================
# Resilience4j Rate Limiter Configuration for GoogleBooksService (Production)
# ======================================================================
# Google Books API default rate limit: 1000 requests/day per user (approximately 42 requests/hour)
# We'll use a more conservative limit to ensure we don't exceed it
google.books.api.request-limit-per-minute=60
resilience4j.ratelimiter.instances.googleBooksServiceRateLimiter.limitRefreshPeriod=1m
# The comment "# Increased from 10" was moved to a separate line or removed for the property below
resilience4j.ratelimiter.instances.googleBooksServiceRateLimiter.limitForPeriod=${google.books.api.request-limit-per-minute:60}
resilience4j.ratelimiter.instances.googleBooksServiceRateLimiter.timeoutDuration=0

# OpenLibrary API rate limiter configuration (1 request per 5 seconds is reasonable)
resilience4j.ratelimiter.instances.openLibraryServiceRateLimiter.limitRefreshPeriod=5s
resilience4j.ratelimiter.instances.openLibraryServiceRateLimiter.limitForPeriod=1
resilience4j.ratelimiter.instances.openLibraryServiceRateLimiter.timeoutDuration=0

# Longitood API rate limiter configuration (limit to 100 requests per minute)
resilience4j.ratelimiter.instances.longitoodServiceRateLimiter.limitRefreshPeriod=1m
resilience4j.ratelimiter.instances.longitoodServiceRateLimiter.limitForPeriod=100
resilience4j.ratelimiter.instances.longitoodServiceRateLimiter.timeoutDuration=0

# S3 Cover Cleanup Utility Configuration
# app.s3.cleanup.run-on-startup=false (This property is no longer used as cleanup is triggered via AdminController)
app.nyt.scheduler.google.books.api.batch-delay-ms=200
app.s3.cleanup.prefix=images/book-covers/
app.s3.cleanup.default-batch-limit=100
app.s3.cleanup.quarantine-prefix=images/non-covers-pages/

# Jackson Pretty Print JSON
spring.jackson.serialization.indent_output=true

# Feature Flags
# Default value, can be overridden by profile-specific properties
app.feature.year-filtering.enabled=false
app.feature.embedding-service.enabled=false

# Security Credentials (Set via environment variables or a secure vault)
# Fallback values are for local development only, ensure real credentials in prod
app.security.admin.password=${APP_ADMIN_PASSWORD:adminpassword_fallback}
app.security.user.password=${APP_USER_PASSWORD:userpassword_fallback}

# New York Times Books API configuration
nyt.api.key=${NYT_API_KEY:}
nyt.api.secret=${NYT_API_SECRET:}
app.nyt.api.base-url=https://api.nytimes.com/svc/books/v3

# New York Times Bestseller Scheduler configuration
app.nyt.scheduler.cron=0 0 4 * * SUN
app.nyt.scheduler.enabled=true
app.nyt.scheduler.google.books.api.rate-limit-per-second=1
app.nyt.scheduler.google.books.api.max-calls-per-job=200

# Redis Configuration for JSON S3 to Redis utility
# Ensure REDIS_SERVER environment variable is set, e.g., rediss://user:pass@host:port/db
spring.redis.url=${REDIS_SERVER}

# S3 paths for JSON S3 to Redis utility
jsontoredis.s3.google-books-prefix=books/v1/
jsontoredis.s3.nyt-bestsellers-key=nyt-bestsellers/latest.json
